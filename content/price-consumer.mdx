---
title: Building a Price Consumer
description: Create a production-ready contract with error handling and staleness checks
---

# Building a Price Consumer

In this tutorial, we'll build a production-ready price consumer contract with proper error handling, staleness validation, and best practices.

## The Contract

<Playground snippetFile="price-consumer.rs" />

## Key Improvements

This contract goes beyond the basic example with:

1. ✅ **Error Handling** - Custom error types for different failure modes
2. ✅ **Staleness Checks** - Validate price freshness
3. ✅ **Price Validation** - Ensure prices are valid
4. ✅ **Helper Functions** - Convenient wrappers for common queries

## Error Handling

### Defining Errors

```rust
#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    PriceNotAvailable = 1,
    PriceTooOld = 2,
    InvalidPrice = 3,
}
```

**Why custom errors?**
- Clear communication of what went wrong
- Easier debugging
- Better user experience

### Error Usage

```rust
pub fn get_fresh_price(/*...*/) -> Result<i128, Error> {
    let price_data = /* query oracle */;
    
    // Check if price exists
    let (price, timestamp) = price_data.ok_or(Error::PriceNotAvailable)?;
    
    // Validate price
    if price <= 0 {
        return Err(Error::InvalidPrice);
    }
    
    Ok(price)
}
```

## Staleness Validation

### Why Check Staleness?

Price data can become outdated. Using stale prices in DeFi can lead to:

- Incorrect liquidations
- Arbitrage opportunities
- Loss of funds

### Implementation

```rust
const MAX_PRICE_AGE: u64 = 300; // 5 minutes

let current_time = env.ledger().timestamp();
if current_time - timestamp > MAX_PRICE_AGE {
    return Err(Error::PriceTooOld);
}
```

**Configuration:**
- **5 minutes** - DeFi protocols, lending
- **1 minute** - High-frequency trading
- **15 minutes** - Less critical applications

## Price Validation

Always validate price data:

```rust
// 1. Check price exists
let (price, timestamp) = price_data.ok_or(Error::PriceNotAvailable)?;

// 2. Check price is positive
if price <= 0 {
    return Err(Error::InvalidPrice);
}

// 3. Check reasonable range (optional)
const MAX_REASONABLE_PRICE: i128 = 1_000_000 * PRICE_DECIMALS;
if price > MAX_REASONABLE_PRICE {
    return Err(Error::InvalidPrice);
}
```

## Helper Functions

### Asset-Specific Queries

Create convenience functions for commonly used assets:

```rust
pub fn get_eth_usd(env: Env, oracle: Address) -> Result<i128, Error> {
    Self::get_fresh_price(
        env,
        oracle,
        symbol_short!("ETH"),
        symbol_short!("USD"),
    )
}

pub fn get_xlm_usd(env: Env, oracle: Address) -> Result<i128, Error> {
    Self::get_fresh_price(
        env,
        oracle,
        symbol_short!("XLM"),
        symbol_short!("USD"),
    )
}
```

### Amount Conversion

Convert asset amounts using oracle prices:

```rust
pub fn convert_amount(
    env: Env,
    oracle: Address,
    amount: i128,
    from_asset: Symbol,
    to_asset: Symbol,
) -> Result<i128, Error> {
    let price = Self::get_fresh_price(env, oracle, from_asset, to_asset)?;
    
    // Price has 14 decimals
    let converted = (amount * price) / 100_000_000_000_000;
    
    Ok(converted)
}
```

**Example:**
```rust
// Convert 10 ETH to USD
let usd_value = contract.convert_amount(
    env,
    oracle,
    10,
    symbol_short!("ETH"),
    symbol_short!("USD"),
);
```

## Testing

### Unit Tests

```rust
#[cfg(test)]
mod test {
    use super::*;
    use soroban_sdk::{testutils::Address as _, Env};

    #[test]
    fn test_staleness_check() {
        let env = Env::default();
        
        // Set ledger timestamp
        env.ledger().with_mut(|li| {
            li.timestamp = 1000;
        });
        
        // Test with fresh price
        let fresh_timestamp = 700; // 300 seconds old
        assert!(1000 - fresh_timestamp <= MAX_PRICE_AGE);
        
        // Test with stale price
        let stale_timestamp = 600; // 400 seconds old
        assert!(1000 - stale_timestamp > MAX_PRICE_AGE);
    }
    
    #[test]
    fn test_invalid_price() {
        let env = Env::default();
        let contract_id = env.register_contract(None, PriceConsumer);
        let client = PriceConsumerClient::new(&env, &contract_id);
        
        // Test negative price rejection
        // (Would need to mock oracle response)
    }
}
```

## Advanced Patterns

### Circuit Breaker

Stop operations if prices become unreliable:

```rust
pub fn get_safe_price(env: Env, oracle: Address) -> Result<i128, Error> {
    let price = Self::get_fresh_price(/*...*/)?;
    
    // Check if price changed too much
    let last_price = get_last_price(&env);
    let price_change = ((price - last_price) * 100) / last_price;
    
    if price_change.abs() > 20 { // 20% change
        return Err(Error::PriceVolatile);
    }
    
    save_last_price(&env, price);
    Ok(price)
}
```

### Multiple Oracle Sources

Aggregate from multiple oracles for redundancy:

```rust
pub fn get_aggregated_price(
    env: Env,
    oracles: Vec<Address>,
) -> Result<i128, Error> {
    let mut prices = Vec::new(&env);
    
    for oracle in oracles.iter() {
        if let Ok(price) = Self::get_fresh_price(env.clone(), oracle, /*...*/) {
            prices.push_back(price);
        }
    }
    
    if prices.len() < 2 {
        return Err(Error::InsufficientOracles);
    }
    
    // Return median price
    Ok(calculate_median(&prices))
}
```

### Weighted Average

Use time-weighted average price (TWAP):

```rust
pub fn get_twap(
    env: Env,
    oracle: Address,
    period: u64,
) -> Result<i128, Error> {
    // Get historical prices
    let prices: Vec<(i128, u64)> = env.invoke_contract(
        &oracle,
        &Symbol::new(&env, "prices"),
        (base, quote, 100).into_val(&env),
    );
    
    // Calculate TWAP over period
    calculate_time_weighted_average(prices, period)
}
```

## Production Checklist

Before deploying to mainnet:

- [ ] ✅ Error handling for all oracle calls
- [ ] ✅ Staleness checks with appropriate timeouts
- [ ] ✅ Price validation (positive, reasonable range)
- [ ] ✅ Comprehensive unit tests
- [ ] ✅ Integration tests with testnet
- [ ] ✅ Gas optimization
- [ ] ✅ Security audit (for high-value contracts)
- [ ] ✅ Circuit breakers for extreme conditions
- [ ] ✅ Monitoring and alerts

## Common Pitfalls

### ❌ Ignoring Staleness

```rust
// BAD: Using price without checking freshness
let (price, _) = oracle_data.unwrap();
use_price(price);
```

```rust
// GOOD: Always check staleness
let (price, timestamp) = oracle_data.unwrap();
if current_time - timestamp > MAX_AGE {
    return Err(Error::PriceTooOld);
}
```

### ❌ Not Handling None

```rust
// BAD: Unwrapping without check
let (price, _) = oracle_data.unwrap();
```

```rust
// GOOD: Proper error handling
let (price, _) = oracle_data.ok_or(Error::PriceNotAvailable)?;
```

### ❌ Wrong Decimal Handling

```rust
// BAD: Forgetting decimals
let value = amount * price;

// GOOD: Accounting for 14 decimals
let value = (amount * price) / 100_000_000_000_000;
```

## Next Steps

Now you know how to build production-ready price consumers! Next:

- [Multi-Asset Queries](/multi-asset) - Query multiple prices efficiently
- [Lending Protocol](/lending-protocol) - Build a complete DeFi protocol
- [Best Practices Guide](https://reflector.network/docs/best-practices)

## Resources

- [Reflector Security Guidelines](https://reflector.network/docs/security)
- [Soroban Error Handling](https://soroban.stellar.org/docs/learn/errors)
- [Testing Guide](https://soroban.stellar.org/docs/learn/testing)

